<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="/2025/04/21/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/04/21/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/21 PM</p>          </div><p>接口是自上而下。我们知道这一行为，基于这些行为我们定义了接口。</p><p>抽象类是自下而上，写了很多类，发现有很多重复代码，封装抽象类继承</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类和基本类型区别是什么？</title>
    <link href="/2025/04/21/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2025/04/21/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/21 PM</p>          </div><p>基本类型：Java有8种基本数据类型(<code>int</code>,<code>long</code>,<code>short</code>,<code>float</code>,<code>double</code>,<code>char</code>,<code>byte</code>,<code>boolean</code>)，它们是存储值的变量，存储在栈上(局部变量存储在栈上、成员变量存储在栈或者是堆上)</p><p>包装类型：每一个基本类型都有其对应的包装类，因为是类所以存储在堆中</p><h2 id="区别">区别</h2><h3 id="性能">性能</h3><ul><li>基本类型占用内存小</li><li>包装类型设计GC、内存分配等、性能低</li></ul><h3 id="等号比较">等号比较</h3><ul><li>基本类型用==</li><li>包装类 == 比较的是对象的内存地址，equal比较的是对象的值</li></ul><h3 id="默认值">默认值</h3><ul><li>基本类型要不0要不false等</li><li>包装类型null</li></ul><h3 id="赋值">赋值</h3><ul><li>直接</li><li>new</li></ul><h2 id="扩展">扩展</h2><h3 id="自动装箱自动拆箱">自动装箱、自动拆箱</h3><p>在某些特定的类中如ArrayList，要求数据类型必须是Object，需要转换</p><p>装箱：基本类型转换为包装型</p><p>拆箱：包装型转换为基本类型</p><p>缓存机制</p><p>例如Interger会对(-128 ~ 127)数据缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Interger</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-type">Interger</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>sout(a == b) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现StringBuffer？</title>
    <link href="/2025/04/21/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0StringBuffer%EF%BC%9F/"/>
    <url>/2025/04/21/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0StringBuffer%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/21 PM</p>          </div><h2 id="引言">引言</h2><p>StringBuffer的出现主要是用来解决拼接String字符串出现创建新字符串，浪费资源的问题。</p><p>大致实现如下</p><ul><li>内部使用char[]数组存储</li><li>添加append、insert操作，修改内部字符数组</li><li>每次操作字符数组，如果空间不够，按照2倍容量扩容，提升性能</li></ul><h2 id="深入剖析">深入剖析</h2><blockquote><p>StringBuffer底层使用char数组用来存值，同时使用count统计插入字符的数量</p></blockquote><h3id="那有人问了string底层代码不也是这样有什么区别吗">那有人问了、String底层代码不也是这样，有什么区别吗？</h3><p>由于StringBuffer递增使用的是char数组存放字符串，而数组是连续内存结构，为了防止频繁申请内存，需要提供初始capacity参数初始化数组大小，这样在知晓大字符串插入的时候，减少扩容次数，主要功能都由父类<code>AbstractStringBuffer</code></p><h3 id="append-op是如何实现int类型转换的">appendOP是如何实现Int类型转换的？</h3><p>首先特判最小值，如果插入的是最小值，直接手动插入</p><p>判断插入的数字占用的字符位数(<code>Interger.stringSize</code>)是否需要扩容</p><p>转换插入，更新现有字符数</p><h3 id="怎么扩容的">怎么扩容的？</h3><p>主要是通过类<code>ensureCapacityInternal</code>扩容</p><p>直接newCapacity 扩容2倍 + 2，同时Arrays.copyOf拷贝</p><p>后面牵扯到位运算，待更。。。。</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java传值按值还是按照引用</title>
    <link href="/2025/04/19/Java%E4%BC%A0%E5%80%BC%E6%8C%89%E5%80%BC%E8%BF%98%E6%98%AF%E6%8C%89%E7%85%A7%E5%BC%95%E7%94%A8/"/>
    <url>/2025/04/19/Java%E4%BC%A0%E5%80%BC%E6%8C%89%E5%80%BC%E8%BF%98%E6%98%AF%E6%8C%89%E7%85%A7%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>Java按值或者是按引用本质上都是值传递。</p><ul><li>基本数据类型：<code>int</code>、<code>char</code>、<code>boolean</code>，传递的是值的副本，对方法参数修改，不会影响值本身</li><li>引用数据类型：传递的是引用的副本、可以对引用对象属性修改，但是引用无法修改</li></ul><p>引用类型的变量存储的是堆内存中的地址</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象和面向过程编程区别</title>
    <link href="/2025/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>面向对象(OOP)：将数据方法封装到一个对象中，并运行封装继承多态作为代码知道</p><p>面向过程编程：用过程作为基本单元，函数和数据分离，根据操作的顺序逐一调用函数</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exception和Error区别</title>
    <link href="/2025/04/19/Exception%E5%92%8CError%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/04/19/Exception%E5%92%8CError%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>两者都是Throwable子类，Java中只有继承了Throwable才可以try...catch....</p><p>总的来说：<code>Exception</code>表示可以处理，<code>Error</code>不可恢复级错误</p><h3 id="细说">细说</h3><p>一、Exception 是程序中可以处理的异常</p><p>常见子类有：IOException、SQLException、NPE</p><p>Exception又可以分为<strong>CheckedException(编译时异常)</strong>和<strong>UncheckedException(运行时异常)</strong></p><ul><li><strong>Checked Exception</strong>：编译时需要显式处理，如trycatch或者通过throw输出。IOException</li><li><strong>Unchecked Exception</strong>：不需要显式处理。如NPE，IllegalArgumentException等都继承RunTimeException</li></ul><p>二、 Error：不可恢复性错误，例如：OutofMemoryError、StackOverflowError</p><h3 id="注意事项">注意事项</h3><p>尽量不要使用Exception捕获异常，捕获指定异常</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String、StringBuffer、StringBuilder区别</title>
    <link href="/2025/04/19/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/04/19/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>1）<strong>String</strong></p><ul><li>不可变：一旦创建无法修改，每一次更改都在创建新对象</li><li>使用场景： 少量字符串拼接操作</li></ul><p>2）<strong>StringBuffer</strong></p><ul><li>可变：增删改</li><li>线程安全：内部使用synchronized</li><li>使用场景：多线程对字符串频繁修改</li></ul><p>3）StringBuilder</p><ul><li>可变：和StringBuffer一样</li><li>非线程安全：线程不安全，但是性能高</li><li>使用场景：单线程大规模修改字符串</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你认为Java有什么优势</title>
    <link href="/2025/04/19/%E4%BD%A0%E8%AE%A4%E4%B8%BAJava%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/"/>
    <url>/2025/04/19/%E4%BD%A0%E8%AE%A4%E4%B8%BAJava%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><h2 id="重点">重点</h2><p>跨平台、GC、生态好、OOP</p><h3 id="跨平台">跨平台</h3><p>Java中夹杂中间层JVM，每台操作系统上只需要有JVM，就可以保证Java运行</p><p>编译执行过程先将Java源码编译成字节码，接着由JVM解释或者JIT编译，JIT编译需要预热，所以提供了AOT，可以直接把字节码转化为机器码</p><p>垃圾回收</p><p>自动垃圾回收机制不容易出错</p><p>生态</p><p>第三方库充足、各种框架、中间件等</p><p>面向对象</p><p>封装继承多态，维护代码起来方便</p><h2 id="拓展知识">拓展知识</h2><h3 id="什么是jitjust-in-time">什么是JIT(Just In Time)？</h3><h4 id="引言">引言</h4><p>JIT即时编译，指的是程序在运行的时候将字节码转换为机器码的技术。</p><p>它在Java程序运行时候，发现频繁执行的代码，于是将这段代码解释成机器码，减少执行开销</p><h4 id="jit编译分类">JIT编译分类</h4><ul><li>C1: 用于快速启动的轻量级优化，常用于客户端应用</li><li>C2：用于长时间启动的重量级优化，常用于服务端应用</li></ul><h4 id="jit调优">JIT调优</h4><p><code>-XX:+PrintCompilation</code>用于输出编译信息</p><p><code>-XX:TieredStopAtLevel</code> 控制JIT编译级别等</p><h3 id="什么是aotahead-of-time">什么是AOT(Ahead Of Time)？</h3><h4 id="引言-1">引言</h4><p>Jav中AOT是指一种在程序运行前，将Java字节码转换为机器码的技术</p><p>相比于JIT运行时，AOT执行时机是在运行前</p><h4 id="工作原理">工作原理</h4><p>AOT编译指的是在构建阶段根据目标平台对Java字节码文件进行静态分析为机器吗。编译好后可以直接运行在硬件上</p><h4 id="优点">优点</h4><ul><li>启动快</li><li>减少JVM的内存占用</li></ul><p>缺点</p><p>无法像JIT一样，运行时对动态信息进行深度优化，长时间运行的应用程序中性能低于JIT</p><p>平台依赖严重：AOP编译出来的机器吗针对于指定平台，无法跨平台</p><h4 id="应用场景">应用场景</h4><p>快速启动应用</p><p>AOT工具。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Java内部类，有什么用？</title>
    <link href="/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/"/>
    <url>/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><h3 id="成员内部类">成员内部类</h3><blockquote><p>定义在另一个类中的类，可以用外部类中的所有变量和方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sdfdsf&quot;</span>;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;hhh&quot;</span> + bb);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createInner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态内部类">静态内部类</h3><blockquote><p>只能访问外部静态成员</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sdfdsf&quot;</span>;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;hhh&quot;</span> + bb);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createInner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部内部类">局部内部类</h3><blockquote><p>在方法中定义的类，只在方法中可见，可以访问外部类的成员和方法哪的局部变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sdfdsf&quot;</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">outMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hhh&quot;</span> + bb);<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.display();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名类">匿名类</h3><blockquote><p>没有类名的类，用于简化接口和继承类的代码</p></blockquote><p>接口简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.KRoot;<br><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        a.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritanceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;喵喵喵~&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        cat.makeSound();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是一个新线程&quot;</span>);<br>            &#125;<br>        &#125;;<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8</title>
    <link href="/2025/04/19/JDK8/"/>
    <url>/2025/04/19/JDK8/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><ul><li>Lambda表达式</li><li>日期类</li><li>Stream流</li><li>Optional</li><li>CompleteableFuture</li></ul><h3 id="lambda">Lambda</h3><p>java8引入的匿名函数，简化了最初的匿名内部类，代码简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>            &#125;<br>        &#125;;<br><br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;FFFF&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期类">日期类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now();<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br></code></pre></td></tr></table></figure><h3 id="stream流">Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">18</span>));<br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-number">18</span>));<br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-number">18</span>));<br><br>        users.stream().map(User::getName).forEach(System.out::println);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="optional">Optional</h3><p>Optional类的出现主要用来解决NPE问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建空的Optional</span><br>        Optional&lt;String&gt; empty = Optional.empty();<br><br>        <span class="hljs-comment">// 2. 创建非空Optional</span><br>        Optional&lt;String&gt; opt1 = Optional.of(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 创建可以包含null的Optional</span><br>        Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-comment">//判断值是否为空</span><br>        System.out.println(opt1.isPresent());<br>        System.out.println(opt2.isEmpty());<br><br>        <br>        <span class="hljs-comment">//值不存在输出默认值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">safeName</span> <span class="hljs-operator">=</span> opt2.orElse(<span class="hljs-string">&quot;value&quot;</span>);<br>        System.out.println(safeName);<br>    <br>        <span class="hljs-type">String</span> <span class="hljs-variable">safeName2</span> <span class="hljs-operator">=</span> opt2.orElseGet(() -&gt; <span class="hljs-string">&quot;DSfsdfdsf&quot;</span>);<br>        System.out.println(safeName2);<br>        <br>        <span class="hljs-comment">//值不存在跑出错误</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">va</span> <span class="hljs-operator">=</span> opt2.orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;sdfdsf&quot;</span>));<br>      <br>      <span class="hljs-comment">//如果存在执行</span><br>      opt1.ifPresent(n -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + n));<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么Java不支持多继承？</title>
    <link href="/2025/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F/"/>
    <url>/2025/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>多继承被称为菱形继承，举一个例子：如果说BC都继承A，D继承BC，D想要调用定义在A中的方法，但是方法在BC有各自的实现，这个时候就会产生歧义。</p><h3 id="拓展">拓展</h3><p>既然多继承行不通，那多实现为什么可以？</p><p>Java8后强制规定，当多实现的时候出现相同方法，需要子类重写该方法</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Java多态特性</title>
    <link href="/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7/"/>
    <url>/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><p>多态指同一个父类对象指向不同子类对象实例，根据指向执行不同行为。</p><h3 id="编译时多态和运行时多态">编译时多态和运行时多态</h3><ol type="1"><li>编译时多态</li></ol><p>编译时多态，又被称为静态多态。主要通过方法重载实现。</p><p>方法重载，返回值一致，方法名一致，参数类型或者是个数不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String b)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Example</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        example.test(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>运行时多态</li></ol><p>运行时多态，又被称为动态多态。主要通过子类重写父类方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.sound();<br>        <br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;叫。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat Bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog Bark&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Java中的不可变类？</title>
    <link href="/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"/>
    <url>/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AFJava%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><blockquote><p>不可变类指的是创建后的对象中字段不可以更改</p></blockquote><h3 id="特征">特征</h3><ul><li>声明类为final，子类无法继承</li><li>类的字段都用private和final修饰</li><li>构造方法初始化所有字段</li><li>不提供getter、setter</li><li>如果类包含可变对象的引用，确保不要在外部修改，可以通过重新new一个新对象来保护可变对象</li></ul><p>java中的不可变类有:<code>String、Integer、BigDecimal、LocalDate</code></p><p>优点：</p><ol type="1"><li>线程安全</li><li>缓存友好</li><li>修改后状态保持一致</li></ol><p>缺点：</p><ol type="1"><li>频繁修改浪费资源</li></ol><h3id="string是如何实现不可变特性的呢">String是如何实现不可变特性的呢？</h3><p>String本质上存值的部分是char数组，使用final修饰，但是final限制不了数组内部的数据，所以需要使用private修饰</p><p>并且不暴露setter，这样外部无法对values进行修改</p><p>replace方法有修改的需求，这个时候我们就会返回一个新对象作为结果</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是序列化和反序列化</title>
    <link href="/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2025/04/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2025/4/19 PM</p>          </div><h1id="java中的序列化和反序列化是什么">Java中的序列化和反序列化是什么</h1><h3 id="序列化">序列化</h3><blockquote><p>序列化可以将对象转化为字节流，从而实现网络传输、持久化存储、缓存，主要使用<code>java.io.Serializable</code>这个接口，类通过实现该接口，就可以对类创建的对象进行序列化</p></blockquote><h3 id="反序列化">反序列化</h3><blockquote><p>将字节流转化为对象的过程，即从存储中读取数据重构对象</p></blockquote><h3 id="场景">场景</h3><p>网络传输、持久化存储都是存储的都是字节序列，如果我们想要存储Java中的对象，需要对对象进行序列化</p><h3 id="拓展">拓展</h3><ul><li>transient 关键字：用来针对不序列化的属性，例如敏感信息</li><li>serialVersionUID：反序列化的时候验证版本一致</li><li>ObjectOutPutStream用于序列化，ObjectInputStream用来反序列化。类必须实现Serialzable接口</li><li>序列化后存储的内容不包含静态变量</li></ul><p>QS</p><p>Q1：为什么叫做字节序列呢？</p><p>Java对象在JVM中是立体的，会存在引用问题，当进行网络传输时，我们需要将引用压扁。</p><p>因为网络的另一端只有内存地址没有指向的引用对象，所以传输时候需要压扁，接收端反序列化压扁后的数据拿到对象。</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM Like HotSpot?</title>
    <link href="/2025/01/02/JVM-Like-HotSpot/"/>
    <url>/2025/01/02/JVM-Like-HotSpot/</url>
    
    <content type="html"><![CDATA[<h1 id="q1jvm-在哪里">Q1：JVM 在哪里？</h1><p>JVM(Java VirtualMachine)是位于操作系统之上的一个环境，在这个环境中，我们同时运行了一堆Java程序。</p><p>JRE包含JVM、操作系统也是安装于硬件之上。</p><p><img src="/img/JVMIMG/1.png" /></p><h1 id="q2jvm体系结构">Q2：JVM体系结构</h1><p><img src="/img/JVMIMG/2.png" /></p><p><img src="/img/JVMIMG/3.png" /></p><h1 id="什么是类加载器的双亲委派机制">什么是类加载器的双亲委派机制</h1><h3 id="类加载流程图">类加载流程图</h3><p><img src="/img/JVMIMG/4.png" /></p><h3 id="模版对象介绍">模版对象介绍</h3><p><img src="/img/JVMIMG/5.png" /></p><h3 id="双亲委派机制">双亲委派机制</h3><p>通过打印我们会发信啊当前使用的是AppClassLoader、父亲为ExtClassLoader、爷爷是NULL(java调用不到、由C实现)</p><p><img src="/img/JVMIMG/6.png" /></p><p>其实不然，为什么以下程序报错，正在我们使用类的时候，他会从AppLoader逐渐过渡到rt.jar发现rt.jar包下的java.lang底下也是有一个叫String的类，优先执行ROOT下的String，而不会执行当前AppLoader中的</p><p><img src="/img/JVMIMG/7.png" /></p><p>所以说双亲委派的流程大致为类加载器收到类加载请求，之后将请求委托给ROOT，如果当前类加载器可以加载这个类，直接结束，否则的话，逐步传递给子类，判断是否可以类加载，最后实在没有就报错</p><h1 id="沙箱安全机制">沙箱安全机制</h1><p><a href="https://www.51cto.com/article/709366.html">详见</a></p><h1 id="native关键字">native关键字</h1><p>凡是带有native关键字的，都会回到本地方法栈，调用本地方法接口(JNI)</p><p>JNI作用：扩展Java的使用，融合不同的语言为Java使用</p><h1 id="pc寄存器">PC寄存器</h1><p>也被称为程序计数器，本质上是一个指针为线程私有</p><h1 id="方法区">方法区</h1><p><img src="/img/JVMIMG/8.png" /></p><p>存储static、final、class、常量池</p><h1 id="栈的实行机制">栈的实行机制</h1><p>栈遵循先进后出的道理</p><p>所以说Main函数在栈中最后弹出，不存在垃圾回收机制</p><p>线程的生命周期和栈是同步的，线程结束，栈被释放</p><p>栈运行原理为栈帧</p><h1 id="jvm有哪些">JVM有哪些？</h1><ul><li>HotSpot</li><li>BEA JRockit</li><li>IBM J9 VM</li></ul><h1 id="堆">堆</h1><p><img src="/img/JVMIMG/9.png" /></p><p>堆区内存满了叫做OOM、堆内存不够</p><p>在JDK8以后永久区叫做元空间</p><h3 id="永久区">永久区</h3><p>存储java运行时的环境以及jdk自带的Class对象、不存在垃圾回收机制</p><ul><li>jdk1.6之前：永久化，常量池存储在永久区中</li><li>jdk1.7：去除永久代，常量池存放到堆中</li><li>jdk1.8：常量池存放到元空间中</li></ul><h3id="如果出现了oom的情况如何解决">如果出现了OOM的情况，如何解决？</h3><p>默认情况下打印内存分配情况</p><p><img src="/img/JVMIMG/10.png" /></p><p><img src="/img/JVMIMG/11.png" /></p><p>根据打印信息我们会发现新生区 + 老年区大小 = 堆区内存大小</p><p><img src="/img/JVMIMG/12.png" /></p><p>因为元空间也属于堆的范畴，但是并没有为其分配空间，所以说元空间物理上并不存在</p><p>GC垃圾回收的机制</p><p>每次向堆中存放数据都会进行轻GC，当新生区满了进行一次重GC，数据存放到老年区，如果最终老年区中的数据也满了报错显示</p><p>使用工具排除问题</p><ul><li>Debug调试代码</li><li>使用内存快照工具，MAT，Jprofiler</li></ul><p>Jprofiler作用</p><ul><li>分析Dump文件，定位内存泄漏</li><li>获取堆中的对象</li></ul><h1 id="gc">GC</h1><h3 id="引用计数法">引用计数法</h3><p>对象每使用一次，将其计数加一，最后将不怎么使用的对象筛选掉</p><p><img src="/img/JVMIMG/13.png" /></p><h3 id="复制算法">复制算法</h3><p><img src="/img/JVMIMG/14.png" /></p><p>每一次GC都会将伊甸园区的数据存放到幸存区，Eden变为空</p><p>幸存From和幸存To如何分辨：谁空谁是To，假设经过GC、Eden中的数据存放到幸存区中，则另一个幸存区由于是空被标识为To，对象流向To，From又为空，接着将From变为To，接着进行GC操作，当操作来到15次对象还没有挂掉就会进入老年区</p><p>15次是默认老年区的GC次数，我们还可以手动设置<code>-XX:MaxTenuringThreshold=15</code></p><p>好处：没有内存碎片</p><p>坏处：浪费内存空间，两个幸存区，一块永远是空的</p><p>复制算法最佳使用场景：对象存活度较低的情况 对应新生区</p><h3 id="标记清除算法">标记清除算法</h3><p>标记活着的对象、清除没有标记的对象</p><p>优点：不需要额外的空间</p><p>缺点：两次扫描、严重浪费时间，会产生内存碎片</p><h3 id="标记压缩算法">标记压缩算法</h3><p><img src="/img/JVMIMG/15.png" /></p><p>再次扫描，将存活的对象向前移动</p><h1 id="jmm是什么">JMM是什么？</h1><p>JVM(Java Memory Model)</p><p>作用：缓存一致性原则，用于定义数据读写规则</p><p>JMM定义了主内存和线程工作内存之间的关系，同时保证了主内存和线程工作内存之间的通信</p><p><img src="/img/JVMIMG/16.png" /></p><p>volilate主要用来解决线程中的数据和主存同步</p>]]></content>
    
    
    <categories>
      
      <category>JavaVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quick Start Docker</title>
    <link href="/2024/10/22/Quick-Start-Docker/"/>
    <url>/2024/10/22/Quick-Start-Docker/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于2024/10/22 PM</p>          </div><h2 id="docker-intro">Docker Intro</h2><p>Docker是一种开源的平台，用于开发、运输和运行应用程序。它通过将应用程序及其依赖项打包在一个可移植的容器中，使得应用程序可以在任何环境中一致地运行。Docker容器利用了操作系统的虚拟化技术，相比传统的虚拟机更加轻量级、高效。开发人员可以在本地构建和测试容器，然后将其部署到生产环境，确保环境一致性和快速部署。Docker极大地简化了应用程序的开发和运维流程，提高了工作效率和系统的可扩展性。</p><p>xx ## 配置与安装</p><p>下载安装<ahref="https://www.docker.com/products/docker-desktop/">docker-desktop</a></p><h2 id="docker入门">Docker入门</h2><h3 id="docker-镜像">Docker 镜像</h3><h4 id="搜索镜像">搜索镜像</h4><table><thead><tr><th>NAME</th><th>DESCRIPTION</th><th>STAR</th><th>OFFICIAL</th></tr></thead><tbody><tr><td>镜像名</td><td>描述</td><td>关注者</td><td>是否为官方镜像(OK)</td></tr></tbody></table><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">docker <span class="hljs-built_in">search</span> 镜像名<span class="hljs-symbol">:</span>对应版本号[可选，默认为最新]<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/1.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="拉取镜像">拉取镜像</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> pull 镜像名<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/4.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="查看已有的镜像">查看已有的镜像</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><figure><img src="/img/dk/2.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="删除镜像">删除镜像</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi 镜像名<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/3.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>镜像是否存在可以从<ahref="https://hub.docker.com/search?q=nginx">DockerHub</a>进行查询</p><h3 id="docker容器">Docker容器</h3><div class="note note-success">            <p>镜像已经准备就绪，容器化编程正式启动，以下拿nginx镜像进行进一步的操作</p>          </div><h4 id="运行一个容器">运行一个容器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># --rm 代表当容器不运行的时候删除当前容器</span><br><span class="hljs-comment"># -d 代表后台运行</span><br><span class="hljs-comment"># -p/P 端口映射 本机:容器内</span><br><span class="hljs-comment"># --name 命名容器</span><br><span class="hljs-attribute">docker</span> run --rm -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx_dk nginx<br></code></pre></td></tr></table></figure><p>运行成功截图 <img src="/img/dk/5.png" alt="alt text" /></p><h4 id="查看容器列表">查看容器列表</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看正在运行的容器列表</span><br>docker <span class="hljs-built_in">ps</span><br><br><span class="hljs-comment"># 查看全部容器(包括已经停止的容器)</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br><br><span class="hljs-comment"># 查看正在运行的容器ID</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span><br><br></code></pre></td></tr></table></figure><h4 id="启动停止删除容器">启动/停止/删除容器</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker start 容器名<span class="hljs-string">/ID</span><br><br>docker stop 容器名<span class="hljs-string">/ID</span><br><br>docker rm -f[可以删除正在运行的容器] 容器名<span class="hljs-string">/ID</span><br></code></pre></td></tr></table></figure><h4 id="进入容器">进入容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it 容器名/ID /bin/bash<br><br></code></pre></td></tr></table></figure><figure><img src="/img/dk/6.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="查看容器信息">查看容器信息</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器名/ID<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/7.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="docker-volume">Docker Volume</h3><div class="note note-warning">            <p>MacOS 是在本地运行xhyve虚拟机管理的docker，容器卷是在虚拟机的文件系统中创建，在macOS的FileSystem无法直接访问。</p>          </div><p>解决方案 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it --privileged <span class="hljs-attribute">--pid</span>=host debian nsenter -t 1 -m -u -n -i sh<br></code></pre></td></tr></table></figure></p><h4 id="数据卷有什么作用">数据卷有什么作用？</h4><p>所谓数据卷，即数据的集合，里面存储了我们写入的数据，当我们需要对当前容器的版本进行修改但并不修改内部内容的时候，我们需要去将本地存储数据的内容cp到新版本容器的对应位置</p><h4 id="为什么需要容器卷">为什么需要容器卷</h4><p><strong>默认情况下容器我们对容器内部内容的更改和容器外部并没有任何关联</strong></p><p>我们可以通过容器卷的形式将内外数据进行关联，从而实现文件目录的映射</p><p>目录结构</p><figure><img src="/img/dk/10.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="数据卷的绑定形式">数据卷的绑定形式</h4><ol type="1"><li>匿名绑定</li></ol><p>匿名绑定只需要绑定容器内的Path</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-attr">--rm</span> -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> nginx_vol -v /usr/share/nginx/<span class="hljs-selector-tag">html</span> nginx<br></code></pre></td></tr></table></figure><p>观察nginx_vol详情信息 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker inspect nginx_vol</span><br></code></pre></td></tr></table></figure></p><figure><img src="/img/dk/11.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ul><li><font>Source</font>: 本地路径</li><li><font>Destination</font>: 数据卷绑定路径</li></ul><p>/var/lib/docker/volumes中我们发现f9c2d3e50bf7f0a2ab83bfbb744596eb60a110c0a62d702ff70bc1a52e7e608c确实存在其中</p><figure><img src="/img/dk/12.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>匿名绑定最终实现了数据的双向性，内外修改都是同步的</p><p>匿名绑定的缺点: 删除了容器内部数据全部消失</p><ol start="2" type="1"><li>具名绑定</li></ol><p>通过刚刚介绍的匿名绑定我们会发现名都是ID的形式，所以现在我们给他起个名看起来好看点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-attr">--rm</span> -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> nginx_vol -v nginx_html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><p>nginx_html就是我们新创建出来的数据卷</p><figure><img src="/img/dk/13.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>同理对应的/var/lib/docker/volumes下也会创建一个nginx_html的文件双向绑定的内容 * 容器内: /usr/share/nginx/html * 容器外:/var/lib/docker/volumes/nginx_html/_data</p><p>具名绑定好处</p><blockquote><p>当我们使用docker rm -f容器的时候，内部volume不会被删除，如果想要删除请使用docker volume rm容器名</p></blockquote><ol start="3" type="1"><li>Bind Mount</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker run --rm -d -P --name nginx_vol -v 主机绝对路径<span class="hljs-symbol">:/usr/share/nginx/html</span> nginx<br><br></code></pre></td></tr></table></figure><p>Bind Mount好处</p><blockquote><p>当我们对容器进行dockerrm操作，我们会发现对主机绑定的目录中的内容根本没有任何影响</p></blockquote><h4 id="常用volume-cmd">常用Volume CMD</h4><ol type="1"><li><p>创建Volume <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">docker <span class="hljs-built_in">volume</span> <span class="hljs-keyword">create</span> vlr<br></code></pre></td></tr></table></figure></p></li><li><p>查看Volume <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure></p></li><li><p>查看具体信息</p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect vlr</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>删除Volume <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">rm</span> vlr</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="docker-仓库">Docker 仓库</h3><p>DockerHub 自主提供的仓库，安全性不好，不推荐使用</p><p><ahref="https://cr.console.aliyun.com/cn-hangzhou/instances">Aliyun</a></p><ol type="1"><li><p>注册个人实例</p></li><li><p>创建命名空间</p></li><li><p>创建镜像仓库</p></li></ol><p>镜像Path: xxx/命名空间/镜像仓库</p><h4 id="上传本地镜像">上传本地镜像</h4><p>进入<font color="red">创建好的本地仓库</font>，按照步骤一步一步进行</p><ol type="1"><li><p>docker login --username=aliyun用户名</p></li><li><p>docker tag [ImageId] xxx/命名空间/镜像仓库:版本号</p></li><li><p>docker push 本地新生成带目录的镜像:版本号</p></li><li><p>本地没有、想要下载上传的镜像: docker pushxxx/命名空间/镜像仓库:[镜像版本号]</p></li></ol><p>上传成功 <img src="/img/dk/8.png" alt="alt text" /></p><p>打好标签的仓库 <img src="/img/dk/9.png" alt="alt text" /></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid+GithubPage</title>
    <link href="/2024/10/19/Fluid+GithubPage/"/>
    <url>/2024/10/19/Fluid+GithubPage/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-fluid-theme-githubpage-搭建个人博客">Hexo + Fluid Theme +GithubPage 搭建个人博客</h2><p>前言</p><ul><li>GithubPage是静态站点托管服务，它可以读取到你上传至仓库中的html、css、javascript代码，运行并且在对应位置进行显示</li><li>Hexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，Hexo提供服务Fluid提供前端页面</li></ul><h3 id="前置条件">1. 前置条件</h3><h4 id="git的安装与配置">1.1 Git的安装与配置</h4><h5 id="安装">安装</h5><p>两种方式</p><ul><li><p>brew安装 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br></code></pre></td></tr></table></figure></p></li><li><p><a href="https://git-scm.com/">官方直达</a></p></li></ul><p>git -v查看版本</p><h6 id="配置">配置</h6><p><ahref="https://www.cnblogs.com/techflow/p/13703721.html">参考链接</a></p><p><strong>name对应Github用户名、email对应Github绑定的邮箱</strong><strong>其中[user]一定要配置好，其余的可以没有</strong> <imgsrc="/img/T1/gf.png" /></p><p><span style="color: red; font-size: 1.2em;">后期常常出现的问题:github,Empty reply from server？</span></p><p><strong>解决方案</strong></p><p>本地生成公钥，查看公钥内容 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github绑定邮箱&quot;</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></p><p>将cat到的内容放入到New SSH Key中 <img src="/img/T1/ssh.png" /></p><h4 id="nodejs安装">1.2 Nodejs安装</h4><p><ahref="https://nodejs.org/en">官方直达</a>或者说可以使用brew安装</p><p>node -v查看版本</p><h4 id="github-创建仓库">1.3 Github 创建仓库</h4><p>创建一个名为用户名.github.io的仓库</p><p><em>初体验(所有的操作都在master中进行，记得修改main -&gt;master)</em></p><ol type="1"><li>我们可以创建一个html页面index.html</li><li>点击Setting，选择GithubPage</li><li>点击Visit Website，如果404，可以查看Actions，生效后访问</li></ol><h3 id="hexo简单使用与结构分析">2. Hexo简单使用与结构分析</h3><h4 id="hexo初体验">2.1 hexo初体验</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ol type="1"><li>hexo初始化项目</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> init<span class="hljs-meta"> [可选]</span><br></code></pre></td></tr></table></figure><p>hexo init 直接在当前文件夹下创建项目内容、hexo init my-blog创建一个my-blog文件夹，同时在里面创建项目内容</p><p>项目结构</p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── _config<span class="hljs-selector-class">.fluid</span><span class="hljs-selector-class">.yml</span><br>├── _config<span class="hljs-selector-class">.landscape</span><span class="hljs-selector-class">.yml</span><br>├── _config<span class="hljs-selector-class">.yml</span><br>├── db<span class="hljs-selector-class">.json</span><br>├── node_modules<br>├── package-lock<span class="hljs-selector-class">.json</span><br>├── package<span class="hljs-selector-class">.json</span><br>├── public<br>├── scaffolds<br>├── <span class="hljs-selector-tag">source</span><br>├── themes<br>└── yarn.lock<br></code></pre></td></tr></table></figure></blockquote><p>启动项目 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure></p><p>接着去浏览器里访问localhost:4000，会看到初始化好的界面</p><p>配置完整后hexo的操作为 <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">hexo clean<br><br>hexo <span class="hljs-selector-tag">g</span><br><br>hexo s<span class="hljs-selector-attr">[预览、可选]</span><br><br>hexo <span class="hljs-built_in">d</span>(下面介绍)<br></code></pre></td></tr></table></figure></p><h4 id="hexo-theme引入">2.2 Hexo-Theme引入</h4><p><a href="https://hexo.io/themes/">Themes</a></p><p>本篇文章只介绍Fluid主题的相关配置</p><h5 id="在博客目录下创建_config.fluid.yml">2.2.1在博客目录下创建_config.fluid.yml</h5><p>默认情况下_config.yml是博客的配置入口，fluid主题将_config.fluid.yml优先级设置的比较高，可能是考虑到不小心把_config.yml改乱了，所以接下来我们只需要设置_config.fluid.yml就可以了</p><ul><li>_config.fluid.yml配置</li></ul><p>基本配置 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span> 标签页内容<br><span class="hljs-symbol">theme:</span> fluid<br><span class="hljs-symbol">author:</span> 设置成自己名(可选)<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br></code></pre></td></tr></table></figure></p><p>添加deploy便于后期上传 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    repo:</span> git@github.com:KoRinALL/KoRinALL.github.io.git (这里我建议使用ssh)<br><span class="hljs-symbol">    branch:</span> master<br></code></pre></td></tr></table></figure></p><p>部署好后，我们可以使用<code>hexo d</code>进行上传文件到仓库中</p><ul><li>博客目录下主要文件介绍</li></ul><p>public: 主要前端文件 html、css、javascript source: - _posts管理md文章的文件 - about 需要自己创建，对应about界面 - img需要自己创建，图片路径优先级比themes下_config.yml 优先级高</p><p>node_modules - hexo-themes-fluid - <em>config.yml 主题配置文件 </em>img和刚才创建的img对应</p><h3 id="插件引入">3. 插件引入</h3><p>-&gt; hexo-themes-fluid/_config.yml</p><blockquote><p>图片更换，文本的更改以及一些很基础的操作这里就不介绍了，我相信各位大佬能自行解决同时学到些新知识～</p></blockquote><p>评论插件包括utterances | disqus | gitalk | valine | waline | changyan| livere | remark42 | twikoo | cusdis | giscus |discuss，我使用的主要是gitalk</p><h4 id="gitalk-comment-不推荐请看3.4-配置waline评论">3.1 Gitalk Comment(不推荐，请看3.4 配置Waline评论)</h4><p><img src="/img/T1/GK.png" /></p><ol type="1"><li><p>来到Github/Setting/Developer Setting/OAuth Apps/New OAuthApps</p></li><li><p>Homepage URL 和Authorization callback URL填写自己仓库地址(一定要是https协议) ex:https://korinall.github.io/，里面会提供Client ID和Client secrets</p></li></ol><p>3.其他设置 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">repo:</span>仓库名<br>owner、admin: 用户名<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br>其余默认<br></code></pre></td></tr></table></figure></p><p>Tip： 效果只有在部署后，初始化给予权限后才可以使用</p><h4 id="latex">3.2 Latex</h4><ol type="1"><li>更改主题配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>更换渲染器渲染器只允许同时存在一个，所以我们需要删除默认的，下载支持Latex的<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li></ol><p>mathjax: <code>npm install hexo-renderer-kramed --save</code></p><p>katex:<code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code></p><p>下载好后，我们只需要在对应的md文章FrontMatter部分添加<code>math: true</code></p><p>Front Matter指的是如下部分 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">ssssss</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></p><h4 id="添加看板娘">3.3 添加看板娘</h4><ol type="1"><li><p>git clone<ahref="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a>到主题的<font color="red">source</font>目录下</p></li><li><p>在主题的<font color="red">layout</font>目录下找到<strong>head.js</strong>添加如下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/live2d-widget/autoload.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>修改autoload.js文件 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// const live2d_path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;</span><span class="hljs-comment">;</span><br>const live2d_path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/live2d-widget/&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p></li><li><p>更改autoload.js下的CDN地址 默认CND地址不可以进行换装，这里使用<ahref="https://akilar.top/posts/5b8f515f/">Akilarの糖果屋</a>的CDN，模型多放心使用<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cdnPath:</span> <span class="hljs-string">&quot;https://npm.elemecdn.com/akilar-live2dapi@latest/&quot;</span><br></code></pre></td></tr></table></figure></p></li><li><p>为了防止看板娘被挡住，我们可以将其图层设置为999，具体操作更改<font color="blue">live2d-widget</font>下的<font color="blue">waifu.css</font><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#waifu &#123;</span><br>    z-<span class="hljs-keyword">index</span>: <span class="hljs-number">999</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>调整看板娘位于右下角，修改配置如下</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#waifu</span> &#123;<br><span class="hljs-attribute">bottom</span>: -<span class="hljs-number">1000px</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">10px</span>;<br><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">3px</span>);<br><span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">3s</span> ease-in-out, bottom <span class="hljs-number">3s</span> ease-in-out;<br><span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;<br>&#125;<br><br><br><span class="hljs-selector-id">#waifu-tool</span> &#123;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>;<br><span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">70px</span>;<br><span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="waline-comment">3.4 Waline Comment</h4><blockquote><p>Gitalk博客每一次都需要管理员初始化感觉挺CS，这里推荐换成Waline</p></blockquote><p>需要用到的网站</p><p>LeanCloud(推荐使用国际版本)：<ahref="https://console.leancloud.app/apps">https://console.leancloud.app/apps</a></p><p><font>如果使用国内版本，需要在LeanCloud上绑定已经备案等域名，Vercel中也需要多添加一步环境变量，具体参考<ahref="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-waline/fluid-waline/">Here!</a></font></p><p>Vercel：<a href="https://vercel.com/">https://vercel.com/</a></p><p><font size=5>LeanCloud</font></p><ol type="1"><li>创建应用实例</li></ol><figure><img src="/img/T1/ca.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="2" type="1"><li><p>来到Setting中完成邮箱验证</p></li><li><p>选择Setting-&gt;App Keys</p></li></ol><p>待会要用AppID、AppKey、MasterKey</p><p><font size=5>Vercel</font></p><ol type="1"><li><p>注册账号(推荐使用github登录)</p></li><li><p><ahref="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&amp;teamSlug=korinalls-projects">点这里</a></p></li><li><p>解锁、添加仓库名</p></li></ol><figure><img src="/img/T1/newpro.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="4" type="1"><li>点击Continue to Dashboard -&gt; Environment Variables</li></ol><p>配置三个环境变量LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。</p><p>它们的值分别对应之前在 LeanCloud 中获得的 APP ID, APP KEY, MasterKey，然后Save。</p><ol start="5" type="1"><li><p>点击顶部栏点Deployments中的Redeploy <imgsrc="/img/T1/redeploy.png" alt="alt text" /></p></li><li><p>回到顶部栏Project -&gt; Visit -&gt; Login</p></li></ol><figure><img src="/img/T1/register.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="7" type="1"><li>这个页面中第一个注册的人默认就是管理员，后期可以使用管理员进行发送消息</li></ol><p><font size=5>主题配置文件(_config.yml)</font></p><p>在原有的基础上只需要将Visit访问的网址填入就可以使用了</p><figure><img src="/img/T1/vs.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>至此，博客已经搭建完毕，其余的内容自行探索，学习永无止境^_^ echoBye！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac技巧-1-应用位置查询</title>
    <link href="/2024/10/19/Mac%E6%8A%80%E5%B7%A7-1-%E5%BA%94%E7%94%A8%E4%BD%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/10/19/Mac%E6%8A%80%E5%B7%A7-1-%E5%BA%94%E7%94%A8%E4%BD%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2024/10/24 PM</p>          </div><p>最近想要删除一个软件，这个软件在控制台中是存在的，通过Command +Space是可以打开的</p><p>但是忘记当时放在访达中什么位置，迫不得已上网查找，可能自己问题描述的有点抽象，没找到。。</p><p>最后去搜索了Spotlight Search的用法，其中介绍了一种查找路径的方法</p><p><font>长按command接着放置到查找的文件上</font>如图所示</p><figure><img src="/img/mac_tip/1.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>成功 ！！！ <img src="/img/mac_tip/2.png" alt="alt text" /></p>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MAC技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
