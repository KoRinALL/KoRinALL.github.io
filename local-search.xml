<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM Like HotSpot?</title>
    <link href="/2025/01/02/JVM-Like-HotSpot/"/>
    <url>/2025/01/02/JVM-Like-HotSpot/</url>
    
    <content type="html"><![CDATA[<h1 id="q1jvm-在哪里">Q1：JVM 在哪里？</h1><p>JVM(Java VirtualMachine)是位于操作系统之上的一个环境，在这个环境中，我们同时运行了一堆Java程序。</p><p>JRE包含JVM、操作系统也是安装于硬件之上。</p><p><img src="/img/JVMIMG/1.png" /></p><h1 id="q2jvm体系结构">Q2：JVM体系结构</h1><p><img src="/img/JVMIMG/2.png" /></p><p><img src="/img/JVMIMG/3.png" /></p><h1 id="什么是类加载器的双亲委派机制">什么是类加载器的双亲委派机制</h1><h3 id="类加载流程图">类加载流程图</h3><p><img src="/img/JVMIMG/4.png" /></p><h3 id="模版对象介绍">模版对象介绍</h3><p><img src="/img/JVMIMG/5.png" /></p><h3 id="双亲委派机制">双亲委派机制</h3><p>通过打印我们会发信啊当前使用的是AppClassLoader、父亲为ExtClassLoader、爷爷是NULL(java调用不到、由C实现)</p><p><img src="/img/JVMIMG/6.png" /></p><p>其实不然，为什么以下程序报错，正在我们使用类的时候，他会从AppLoader逐渐过渡到rt.jar发现rt.jar包下的java.lang底下也是有一个叫String的类，优先执行ROOT下的String，而不会执行当前AppLoader中的</p><p><img src="/img/JVMIMG/7.png" /></p><p>所以说双亲委派的流程大致为类加载器收到类加载请求，之后将请求委托给ROOT，如果当前类加载器可以加载这个类，直接结束，否则的话，逐步传递给子类，判断是否可以类加载，最后实在没有就报错</p><h1 id="沙箱安全机制">沙箱安全机制</h1><p><a href="https://www.51cto.com/article/709366.html">详见</a></p><h1 id="native关键字">native关键字</h1><p>凡是带有native关键字的，都会回到本地方法栈，调用本地方法接口(JNI)</p><p>JNI作用：扩展Java的使用，融合不同的语言为Java使用</p><h1 id="pc寄存器">PC寄存器</h1><p>也被称为程序计数器，本质上是一个指针为线程私有</p><h1 id="方法区">方法区</h1><p><img src="/img/JVMIMG/8.png" /></p><p>存储static、final、class、常量池</p><h1 id="栈的实行机制">栈的实行机制</h1><p>栈遵循先进后出的道理</p><p>所以说Main函数在栈中最后弹出，不存在垃圾回收机制</p><p>线程的生命周期和栈是同步的，线程结束，栈被释放</p><p>栈运行原理为栈帧</p><h1 id="jvm有哪些">JVM有哪些？</h1><ul><li>HotSpot</li><li>BEA JRockit</li><li>IBM J9 VM</li></ul><h1 id="堆">堆</h1><p><img src="/img/JVMIMG/9.png" /></p><p>堆区内存满了叫做OOM、堆内存不够</p><p>在JDK8以后永久区叫做元空间</p><h3 id="永久区">永久区</h3><p>存储java运行时的环境以及jdk自带的Class对象、不存在垃圾回收机制</p><ul><li>jdk1.6之前：永久化，常量池存储在永久区中</li><li>jdk1.7：去除永久代，常量池存放到堆中</li><li>jdk1.8：常量池存放到元空间中</li></ul><h3id="如果出现了oom的情况如何解决">如果出现了OOM的情况，如何解决？</h3><p>默认情况下打印内存分配情况</p><p><img src="/img/JVMIMG/10.png" /></p><p><img src="/img/JVMIMG/11.png" /></p><p>根据打印信息我们会发现新生区 + 老年区大小 = 堆区内存大小</p><p><img src="/img/JVMIMG/12.png" /></p><p>因为元空间也属于堆的范畴，但是并没有为其分配空间，所以说元空间物理上并不存在</p><p>GC垃圾回收的机制</p><p>每次向堆中存放数据都会进行轻GC，当新生区满了进行一次重GC，数据存放到老年区，如果最终老年区中的数据也满了报错显示</p><p>使用工具排除问题</p><ul><li>Debug调试代码</li><li>使用内存快照工具，MAT，Jprofiler</li></ul><p>Jprofiler作用</p><ul><li>分析Dump文件，定位内存泄漏</li><li>获取堆中的对象</li></ul><h1 id="gc">GC</h1><h3 id="引用计数法">引用计数法</h3><p>对象每使用一次，将其计数加一，最后将不怎么使用的对象筛选掉</p><p><img src="/img/JVMIMG/13.png" /></p><h3 id="复制算法">复制算法</h3><p><img src="/img/JVMIMG/14.png" /></p><p>每一次GC都会将伊甸园区的数据存放到幸存区，Eden变为空</p><p>幸存From和幸存To如何分辨：谁空谁是To，假设经过GC、Eden中的数据存放到幸存区中，则另一个幸存区由于是空被标识为To，对象流向To，From又为空，接着将From变为To，接着进行GC操作，当操作来到15次对象还没有挂掉就会进入老年区</p><p>15次是默认老年区的GC次数，我们还可以手动设置<code>-XX:MaxTenuringThreshold=15</code></p><p>好处：没有内存碎片</p><p>坏处：浪费内存空间，两个幸存区，一块永远是空的</p><p>复制算法最佳使用场景：对象存活度较低的情况 对应新生区</p><h3 id="标记清除算法">标记清除算法</h3><p>标记活着的对象、清除没有标记的对象</p><p>优点：不需要额外的空间</p><p>缺点：两次扫描、严重浪费时间，会产生内存碎片</p><h3 id="标记压缩算法">标记压缩算法</h3><p><img src="/img/JVMIMG/15.png" /></p><p>再次扫描，将存活的对象向前移动</p><h1 id="jmm是什么">JMM是什么？</h1><p>JVM(Java Memory Model)</p><p>作用：缓存一致性原则，用于定义数据读写规则</p><p>JMM定义了主内存和线程工作内存之间的关系，同时保证了主内存和线程工作内存之间的通信</p><p><img src="/img/JVMIMG/16.png" /></p><p>volilate主要用来解决线程中的数据和主存同步</p>]]></content>
    
    
    <categories>
      
      <category>JavaVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quick Start Docker</title>
    <link href="/2024/10/22/Quick-Start-Docker/"/>
    <url>/2024/10/22/Quick-Start-Docker/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于2024/10/22 PM</p>          </div><h2 id="docker-intro">Docker Intro</h2><p>Docker是一种开源的平台，用于开发、运输和运行应用程序。它通过将应用程序及其依赖项打包在一个可移植的容器中，使得应用程序可以在任何环境中一致地运行。Docker容器利用了操作系统的虚拟化技术，相比传统的虚拟机更加轻量级、高效。开发人员可以在本地构建和测试容器，然后将其部署到生产环境，确保环境一致性和快速部署。Docker极大地简化了应用程序的开发和运维流程，提高了工作效率和系统的可扩展性。</p><p>xx ## 配置与安装</p><p>下载安装<ahref="https://www.docker.com/products/docker-desktop/">docker-desktop</a></p><h2 id="docker入门">Docker入门</h2><h3 id="docker-镜像">Docker 镜像</h3><h4 id="搜索镜像">搜索镜像</h4><table><thead><tr><th>NAME</th><th>DESCRIPTION</th><th>STAR</th><th>OFFICIAL</th></tr></thead><tbody><tr><td>镜像名</td><td>描述</td><td>关注者</td><td>是否为官方镜像(OK)</td></tr></tbody></table><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">docker <span class="hljs-built_in">search</span> 镜像名<span class="hljs-symbol">:</span>对应版本号[可选，默认为最新]<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/1.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="拉取镜像">拉取镜像</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> pull 镜像名<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/4.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="查看已有的镜像">查看已有的镜像</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><figure><img src="/img/dk/2.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="删除镜像">删除镜像</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi 镜像名<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/3.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>镜像是否存在可以从<ahref="https://hub.docker.com/search?q=nginx">DockerHub</a>进行查询</p><h3 id="docker容器">Docker容器</h3><div class="note note-success">            <p>镜像已经准备就绪，容器化编程正式启动，以下拿nginx镜像进行进一步的操作</p>          </div><h4 id="运行一个容器">运行一个容器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># --rm 代表当容器不运行的时候删除当前容器</span><br><span class="hljs-comment"># -d 代表后台运行</span><br><span class="hljs-comment"># -p/P 端口映射 本机:容器内</span><br><span class="hljs-comment"># --name 命名容器</span><br><span class="hljs-attribute">docker</span> run --rm -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx_dk nginx<br></code></pre></td></tr></table></figure><p>运行成功截图 <img src="/img/dk/5.png" alt="alt text" /></p><h4 id="查看容器列表">查看容器列表</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看正在运行的容器列表</span><br>docker <span class="hljs-built_in">ps</span><br><br><span class="hljs-comment"># 查看全部容器(包括已经停止的容器)</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br><br><span class="hljs-comment"># 查看正在运行的容器ID</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span><br><br></code></pre></td></tr></table></figure><h4 id="启动停止删除容器">启动/停止/删除容器</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker start 容器名<span class="hljs-string">/ID</span><br><br>docker stop 容器名<span class="hljs-string">/ID</span><br><br>docker rm -f[可以删除正在运行的容器] 容器名<span class="hljs-string">/ID</span><br></code></pre></td></tr></table></figure><h4 id="进入容器">进入容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it 容器名/ID /bin/bash<br><br></code></pre></td></tr></table></figure><figure><img src="/img/dk/6.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="查看容器信息">查看容器信息</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器名/ID<br></code></pre></td></tr></table></figure><figure><img src="/img/dk/7.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="docker-volume">Docker Volume</h3><div class="note note-warning">            <p>MacOS 是在本地运行xhyve虚拟机管理的docker，容器卷是在虚拟机的文件系统中创建，在macOS的FileSystem无法直接访问。</p>          </div><p>解决方案 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it --privileged <span class="hljs-attribute">--pid</span>=host debian nsenter -t 1 -m -u -n -i sh<br></code></pre></td></tr></table></figure></p><h4 id="数据卷有什么作用">数据卷有什么作用？</h4><p>所谓数据卷，即数据的集合，里面存储了我们写入的数据，当我们需要对当前容器的版本进行修改但并不修改内部内容的时候，我们需要去将本地存储数据的内容cp到新版本容器的对应位置</p><h4 id="为什么需要容器卷">为什么需要容器卷</h4><p><strong>默认情况下容器我们对容器内部内容的更改和容器外部并没有任何关联</strong></p><p>我们可以通过容器卷的形式将内外数据进行关联，从而实现文件目录的映射</p><p>目录结构</p><figure><img src="/img/dk/10.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h4 id="数据卷的绑定形式">数据卷的绑定形式</h4><ol type="1"><li>匿名绑定</li></ol><p>匿名绑定只需要绑定容器内的Path</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-attr">--rm</span> -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> nginx_vol -v /usr/share/nginx/<span class="hljs-selector-tag">html</span> nginx<br></code></pre></td></tr></table></figure><p>观察nginx_vol详情信息 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker inspect nginx_vol</span><br></code></pre></td></tr></table></figure></p><figure><img src="/img/dk/11.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ul><li><font>Source</font>: 本地路径</li><li><font>Destination</font>: 数据卷绑定路径</li></ul><p>/var/lib/docker/volumes中我们发现f9c2d3e50bf7f0a2ab83bfbb744596eb60a110c0a62d702ff70bc1a52e7e608c确实存在其中</p><figure><img src="/img/dk/12.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>匿名绑定最终实现了数据的双向性，内外修改都是同步的</p><p>匿名绑定的缺点: 删除了容器内部数据全部消失</p><ol start="2" type="1"><li>具名绑定</li></ol><p>通过刚刚介绍的匿名绑定我们会发现名都是ID的形式，所以现在我们给他起个名看起来好看点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-attr">--rm</span> -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> nginx_vol -v nginx_html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><p>nginx_html就是我们新创建出来的数据卷</p><figure><img src="/img/dk/13.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>同理对应的/var/lib/docker/volumes下也会创建一个nginx_html的文件双向绑定的内容 * 容器内: /usr/share/nginx/html * 容器外:/var/lib/docker/volumes/nginx_html/_data</p><p>具名绑定好处</p><blockquote><p>当我们使用docker rm -f容器的时候，内部volume不会被删除，如果想要删除请使用docker volume rm容器名</p></blockquote><ol start="3" type="1"><li>Bind Mount</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker run --rm -d -P --name nginx_vol -v 主机绝对路径<span class="hljs-symbol">:/usr/share/nginx/html</span> nginx<br><br></code></pre></td></tr></table></figure><p>Bind Mount好处</p><blockquote><p>当我们对容器进行dockerrm操作，我们会发现对主机绑定的目录中的内容根本没有任何影响</p></blockquote><h4 id="常用volume-cmd">常用Volume CMD</h4><ol type="1"><li><p>创建Volume <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">docker <span class="hljs-built_in">volume</span> <span class="hljs-keyword">create</span> vlr<br></code></pre></td></tr></table></figure></p></li><li><p>查看Volume <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure></p></li><li><p>查看具体信息</p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect vlr</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>删除Volume <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">rm</span> vlr</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="docker-仓库">Docker 仓库</h3><p>DockerHub 自主提供的仓库，安全性不好，不推荐使用</p><p><ahref="https://cr.console.aliyun.com/cn-hangzhou/instances">Aliyun</a></p><ol type="1"><li><p>注册个人实例</p></li><li><p>创建命名空间</p></li><li><p>创建镜像仓库</p></li></ol><p>镜像Path: xxx/命名空间/镜像仓库</p><h4 id="上传本地镜像">上传本地镜像</h4><p>进入<font color="red">创建好的本地仓库</font>，按照步骤一步一步进行</p><ol type="1"><li><p>docker login --username=aliyun用户名</p></li><li><p>docker tag [ImageId] xxx/命名空间/镜像仓库:版本号</p></li><li><p>docker push 本地新生成带目录的镜像:版本号</p></li><li><p>本地没有、想要下载上传的镜像: docker pushxxx/命名空间/镜像仓库:[镜像版本号]</p></li></ol><p>上传成功 <img src="/img/dk/8.png" alt="alt text" /></p><p>打好标签的仓库 <img src="/img/dk/9.png" alt="alt text" /></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid+GithubPage</title>
    <link href="/2024/10/19/Fluid+GithubPage/"/>
    <url>/2024/10/19/Fluid+GithubPage/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-fluid-theme-githubpage-搭建个人博客">Hexo + Fluid Theme +GithubPage 搭建个人博客</h2><p>前言</p><ul><li>GithubPage是静态站点托管服务，它可以读取到你上传至仓库中的html、css、javascript代码，运行并且在对应位置进行显示</li><li>Hexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，Hexo提供服务Fluid提供前端页面</li></ul><h3 id="前置条件">1. 前置条件</h3><h4 id="git的安装与配置">1.1 Git的安装与配置</h4><h5 id="安装">安装</h5><p>两种方式</p><ul><li><p>brew安装 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br></code></pre></td></tr></table></figure></p></li><li><p><a href="https://git-scm.com/">官方直达</a></p></li></ul><p>git -v查看版本</p><h6 id="配置">配置</h6><p><ahref="https://www.cnblogs.com/techflow/p/13703721.html">参考链接</a></p><p><strong>name对应Github用户名、email对应Github绑定的邮箱</strong><strong>其中[user]一定要配置好，其余的可以没有</strong> <imgsrc="/img/T1/gf.png" /></p><p><span style="color: red; font-size: 1.2em;">后期常常出现的问题:github,Empty reply from server？</span></p><p><strong>解决方案</strong></p><p>本地生成公钥，查看公钥内容 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github绑定邮箱&quot;</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></p><p>将cat到的内容放入到New SSH Key中 <img src="/img/T1/ssh.png" /></p><h4 id="nodejs安装">1.2 Nodejs安装</h4><p><ahref="https://nodejs.org/en">官方直达</a>或者说可以使用brew安装</p><p>node -v查看版本</p><h4 id="github-创建仓库">1.3 Github 创建仓库</h4><p>创建一个名为用户名.github.io的仓库</p><p><em>初体验(所有的操作都在master中进行，记得修改main -&gt;master)</em></p><ol type="1"><li>我们可以创建一个html页面index.html</li><li>点击Setting，选择GithubPage</li><li>点击Visit Website，如果404，可以查看Actions，生效后访问</li></ol><h3 id="hexo简单使用与结构分析">2. Hexo简单使用与结构分析</h3><h4 id="hexo初体验">2.1 hexo初体验</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ol type="1"><li>hexo初始化项目</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> init<span class="hljs-meta"> [可选]</span><br></code></pre></td></tr></table></figure><p>hexo init 直接在当前文件夹下创建项目内容、hexo init my-blog创建一个my-blog文件夹，同时在里面创建项目内容</p><p>项目结构</p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── _config<span class="hljs-selector-class">.fluid</span><span class="hljs-selector-class">.yml</span><br>├── _config<span class="hljs-selector-class">.landscape</span><span class="hljs-selector-class">.yml</span><br>├── _config<span class="hljs-selector-class">.yml</span><br>├── db<span class="hljs-selector-class">.json</span><br>├── node_modules<br>├── package-lock<span class="hljs-selector-class">.json</span><br>├── package<span class="hljs-selector-class">.json</span><br>├── public<br>├── scaffolds<br>├── <span class="hljs-selector-tag">source</span><br>├── themes<br>└── yarn.lock<br></code></pre></td></tr></table></figure></blockquote><p>启动项目 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure></p><p>接着去浏览器里访问localhost:4000，会看到初始化好的界面</p><p>配置完整后hexo的操作为 <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">hexo clean<br><br>hexo <span class="hljs-selector-tag">g</span><br><br>hexo s<span class="hljs-selector-attr">[预览、可选]</span><br><br>hexo <span class="hljs-built_in">d</span>(下面介绍)<br></code></pre></td></tr></table></figure></p><h4 id="hexo-theme引入">2.2 Hexo-Theme引入</h4><p><a href="https://hexo.io/themes/">Themes</a></p><p>本篇文章只介绍Fluid主题的相关配置</p><h5 id="在博客目录下创建_config.fluid.yml">2.2.1在博客目录下创建_config.fluid.yml</h5><p>默认情况下_config.yml是博客的配置入口，fluid主题将_config.fluid.yml优先级设置的比较高，可能是考虑到不小心把_config.yml改乱了，所以接下来我们只需要设置_config.fluid.yml就可以了</p><ul><li>_config.fluid.yml配置</li></ul><p>基本配置 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span> 标签页内容<br><span class="hljs-symbol">theme:</span> fluid<br><span class="hljs-symbol">author:</span> 设置成自己名(可选)<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br></code></pre></td></tr></table></figure></p><p>添加deploy便于后期上传 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    repo:</span> git@github.com:KoRinALL/KoRinALL.github.io.git (这里我建议使用ssh)<br><span class="hljs-symbol">    branch:</span> master<br></code></pre></td></tr></table></figure></p><p>部署好后，我们可以使用<code>hexo d</code>进行上传文件到仓库中</p><ul><li>博客目录下主要文件介绍</li></ul><p>public: 主要前端文件 html、css、javascript source: - _posts管理md文章的文件 - about 需要自己创建，对应about界面 - img需要自己创建，图片路径优先级比themes下_config.yml 优先级高</p><p>node_modules - hexo-themes-fluid - <em>config.yml 主题配置文件 </em>img和刚才创建的img对应</p><h3 id="插件引入">3. 插件引入</h3><p>-&gt; hexo-themes-fluid/_config.yml</p><blockquote><p>图片更换，文本的更改以及一些很基础的操作这里就不介绍了，我相信各位大佬能自行解决同时学到些新知识～</p></blockquote><p>评论插件包括utterances | disqus | gitalk | valine | waline | changyan| livere | remark42 | twikoo | cusdis | giscus |discuss，我使用的主要是gitalk</p><h4 id="gitalk-comment-不推荐请看3.4-配置waline评论">3.1 Gitalk Comment(不推荐，请看3.4 配置Waline评论)</h4><p><img src="/img/T1/GK.png" /></p><ol type="1"><li><p>来到Github/Setting/Developer Setting/OAuth Apps/New OAuthApps</p></li><li><p>Homepage URL 和Authorization callback URL填写自己仓库地址(一定要是https协议) ex:https://korinall.github.io/，里面会提供Client ID和Client secrets</p></li></ol><p>3.其他设置 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">repo:</span>仓库名<br>owner、admin: 用户名<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br>其余默认<br></code></pre></td></tr></table></figure></p><p>Tip： 效果只有在部署后，初始化给予权限后才可以使用</p><h4 id="latex">3.2 Latex</h4><ol type="1"><li>更改主题配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>更换渲染器渲染器只允许同时存在一个，所以我们需要删除默认的，下载支持Latex的<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li></ol><p>mathjax: <code>npm install hexo-renderer-kramed --save</code></p><p>katex:<code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code></p><p>下载好后，我们只需要在对应的md文章FrontMatter部分添加<code>math: true</code></p><p>Front Matter指的是如下部分 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">ssssss</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></p><h4 id="添加看板娘">3.3 添加看板娘</h4><ol type="1"><li><p>git clone<ahref="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a>到主题的<font color="red">source</font>目录下</p></li><li><p>在主题的<font color="red">layout</font>目录下找到<strong>head.js</strong>添加如下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/live2d-widget/autoload.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>修改autoload.js文件 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// const live2d_path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;</span><span class="hljs-comment">;</span><br>const live2d_path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/live2d-widget/&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p></li><li><p>更改autoload.js下的CDN地址 默认CND地址不可以进行换装，这里使用<ahref="https://akilar.top/posts/5b8f515f/">Akilarの糖果屋</a>的CDN，模型多放心使用<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cdnPath:</span> <span class="hljs-string">&quot;https://npm.elemecdn.com/akilar-live2dapi@latest/&quot;</span><br></code></pre></td></tr></table></figure></p></li><li><p>为了防止看板娘被挡住，我们可以将其图层设置为999，具体操作更改<font color="blue">live2d-widget</font>下的<font color="blue">waifu.css</font><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#waifu &#123;</span><br>    z-<span class="hljs-keyword">index</span>: <span class="hljs-number">999</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>调整看板娘位于右下角，修改配置如下</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#waifu</span> &#123;<br><span class="hljs-attribute">bottom</span>: -<span class="hljs-number">1000px</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">10px</span>;<br><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">3px</span>);<br><span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">3s</span> ease-in-out, bottom <span class="hljs-number">3s</span> ease-in-out;<br><span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;<br>&#125;<br><br><br><span class="hljs-selector-id">#waifu-tool</span> &#123;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>;<br><span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">70px</span>;<br><span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="waline-comment">3.4 Waline Comment</h4><blockquote><p>Gitalk博客每一次都需要管理员初始化感觉挺CS，这里推荐换成Waline</p></blockquote><p>需要用到的网站</p><p>LeanCloud(推荐使用国际版本)：<ahref="https://console.leancloud.app/apps">https://console.leancloud.app/apps</a></p><p><font>如果使用国内版本，需要在LeanCloud上绑定已经备案等域名，Vercel中也需要多添加一步环境变量，具体参考<ahref="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-waline/fluid-waline/">Here!</a></font></p><p>Vercel：<a href="https://vercel.com/">https://vercel.com/</a></p><p><font size=5>LeanCloud</font></p><ol type="1"><li>创建应用实例</li></ol><figure><img src="/img/T1/ca.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="2" type="1"><li><p>来到Setting中完成邮箱验证</p></li><li><p>选择Setting-&gt;App Keys</p></li></ol><p>待会要用AppID、AppKey、MasterKey</p><p><font size=5>Vercel</font></p><ol type="1"><li><p>注册账号(推荐使用github登录)</p></li><li><p><ahref="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&amp;teamSlug=korinalls-projects">点这里</a></p></li><li><p>解锁、添加仓库名</p></li></ol><figure><img src="/img/T1/newpro.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="4" type="1"><li>点击Continue to Dashboard -&gt; Environment Variables</li></ol><p>配置三个环境变量LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。</p><p>它们的值分别对应之前在 LeanCloud 中获得的 APP ID, APP KEY, MasterKey，然后Save。</p><ol start="5" type="1"><li><p>点击顶部栏点Deployments中的Redeploy <imgsrc="/img/T1/redeploy.png" alt="alt text" /></p></li><li><p>回到顶部栏Project -&gt; Visit -&gt; Login</p></li></ol><figure><img src="/img/T1/register.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol start="7" type="1"><li>这个页面中第一个注册的人默认就是管理员，后期可以使用管理员进行发送消息</li></ol><p><font size=5>主题配置文件(_config.yml)</font></p><p>在原有的基础上只需要将Visit访问的网址填入就可以使用了</p><figure><img src="/img/T1/vs.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>至此，博客已经搭建完毕，其余的内容自行探索，学习永无止境^_^ echoBye！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac技巧-1-应用位置查询</title>
    <link href="/2024/10/19/Mac%E6%8A%80%E5%B7%A7-1-%E5%BA%94%E7%94%A8%E4%BD%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/10/19/Mac%E6%8A%80%E5%B7%A7-1-%E5%BA%94%E7%94%A8%E4%BD%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>最后更新于：2024/10/24 PM</p>          </div><p>最近想要删除一个软件，这个软件在控制台中是存在的，通过Command +Space是可以打开的</p><p>但是忘记当时放在访达中什么位置，迫不得已上网查找，可能自己问题描述的有点抽象，没找到。。</p><p>最后去搜索了Spotlight Search的用法，其中介绍了一种查找路径的方法</p><p><font>长按command接着放置到查找的文件上</font>如图所示</p><figure><img src="/img/mac_tip/1.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>成功 ！！！ <img src="/img/mac_tip/2.png" alt="alt text" /></p>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MAC技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/19/hello-world/"/>
    <url>/2024/10/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><ol type="1"><li>sdfdsf</li><li>dsfsdf</li><li>sdfds</li></ol><blockquote><p>你好啊</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
